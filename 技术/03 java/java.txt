1. 线程是进程基础上的划分，所有线程都是进程上并发执行
   线程消失进程不会消失，
方式：
 继承Thread类；覆写run()得到线程主体
     start() 启动线程主体，只能启动一次
     不可以实现资源共享
     局限：单继承
 实现Runnable接口；
     利用Thread类构造方法，Runnable的实现子类构造的，启动多线程
     能实现资源共享
     增强了程序健壮性，代码能共享，数据与代码独立
 综上，Runnable最好
 Thread类是Runnable的实现子类

 创建状态：
 就绪状态：
 运行状态：
 阻塞状态：
 死亡状态：

 java至少启动两个线程：GC main
 线程强制执行：join()
 线程休眠：sleep()
 线程的中断：interrupt(),中断休眠
 后天线程：setDaemon()
 优先级：
 礼让：yield()
 同步与死锁：解决票数变负数，解决资源共享同步操作
    同步代码块：synchronized(同步对象) {
    	需要同步的代码
    }
    同步方法：sychronized 同步方法
死锁：程序中过多同步会产生死锁。互相等待

通过设置标志位让线程停止运行

2.栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中
堆：存放用new产生的数据
静态域：存放在对象中用static定义的静态成员
常量池：存放常量
非RAM存储：硬盘等永久存储空间

3.由大到小需要强制转换，由小到大不需要

4.abstract关键字不可以与final，private,static关键字共存；

6. 并发：在 操作系统 中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个 处理机 上运行。其中两种并发关系分别是同步和互斥
 . 互斥：进程间相互排斥的使用临界资源的现象，就叫互斥。
 . 同步： 进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。 

 . 并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。

 . 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。
 . 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
   异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。

7. 运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
       运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 
非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

8. 发生对象向上转型后，调用的方法一定是被子类覆写过的方法。
向下转型时，先使用instance判断是哪个子类的实例，以保证程序运行正确。
不要继承已经实现好的类。
模板设计模式——抽象类的应用；
制定标准——接口的实际应用。
工厂设计模式
代理设计
适配器设计
匿名内部类
Object可以接收任意类的引用类型。
不要在主方法中使用throws
try catch throw finally throws联合使用
RuntimeException可以不交给try-catch处理
不提倡断言的使用
java新特性：静态导入
Runnable接口实现多线程



